using UnityEngine;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text.RegularExpressions;

using Soomla;
using Soomla.Levelup;
using Soomla.Store;
using Soomla.Store.Example;

namespace Soomla.Test {
	public class BasicTest : MonoBehaviour {

		private const string TAG = "SOOMLA-TEST BasicTest";

		// used for testing ad-hoc GatesList generated by World
		public Regex UUID_REGEX =
			new Regex("[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}");
		
		public const string ITEM_ID_BALANCE_GATE = "item_balance_gate";
		public const string ITEM_ID_BALANCE_MISSION = "balance_mission_item_id";
		public const string ITEM_ID_BALANCE_MISSION_REWARD = "balance_mission_reward_item_id";
		public const string ITEM_ID_PURCHASE_GATE_VI = "item_purchase_gate_vi";
		public const string ITEM_ID_PURCHASE_GATE_MARKET = "item_purchase_gate_market";
		public const string ITEM_ID_VI_SCORE = "item_vi_score";
		public const string ITEM_ID_VI_REWARD = "item_vi_reward";
		
		private static bool sAssertionError = false;
		private static string sTestLog;

		private Queue<Dictionary<string, object>> _eventQueue;

		GUIStyle _textStyle = new GUIStyle();
		public Vector2 scrollPosition = Vector2.zero;
		Touch touch;
		float scrollVelocity;
		float timeTouchPhaseEnded;
		float inertiaDuration = 0.5f;

		private class Assert {

			public static bool assertTrue(bool cond) {
				if (!cond) {
					sAssertionError = true;
					sTestLog += "<color=red>FAIL!</color>\n";
//					sTestLog += UnityEngine.StackTraceUtility.ExtractStackTrace () + "\n";
					sTestLog += UnityEngine.StackTraceUtility.ExtractStackTrace () + "\n";
					UnityEngine.Debug.LogException(new Exception("assertTrue"));
//					throw new Exception("assertTrue");
					return false;
				}

				return true;
			}
			public static bool assertFalse(bool cond) {
				if (cond) {
					sAssertionError = true;
					sTestLog += "<color=red>FAIL!</color>\n";
//					sTestLog += UnityEngine.StackTraceUtility.ExtractStackTrace () + "\n";
					sTestLog += UnityEngine.StackTraceUtility.ExtractStackTrace () + "\n";
					UnityEngine.Debug.LogException(new Exception("assertTrue"));
//					throw new Exception("assertTrue");
					return false;
				}

				return true;
			}
			public static bool assertEquals<T>(T expected, T actual) {
				if (!expected.Equals (actual)) {
					sAssertionError = true;
					sTestLog += string.Format("<color=red>FAIL! expected:{0} actual:{1}</color>\n", expected, actual);
//					sTestLog += UnityEngine.StackTraceUtility.ExtractStackTrace () + "\n";
					sTestLog += UnityEngine.StackTraceUtility.ExtractStackTrace () + "\n";
					UnityEngine.Debug.LogException(new Exception(expected + "!=" + actual));
//					throw new Exception(expected + "!=" + actual);
					return false;
				}

				return true;
			}
			public static bool assertEquals(double actual, double expected, double percision) {
				if (Math.Abs(actual-expected) > percision) {
					sAssertionError = true;
					sTestLog += string.Format("<color=red>FAIL! expected:{0} actual:{1} percision:{2}</color>\n", expected, actual, percision);
					sTestLog += UnityEngine.StackTraceUtility.ExtractStackTrace () + "\n";
					UnityEngine.Debug.LogException(new Exception(expected + "!=" + actual + "(percision:" + percision + ")"));
//					throw new Exception(expected + "!=" + actual);
					return false;
				}

				return true;
			}

			public static void fail(Exception e) {
				sAssertionError = true;
				sTestLog += "<color=red>FAIL!</color>\n";
				//					sTestLog += UnityEngine.StackTraceUtility.ExtractStackTrace () + "\n";
				sTestLog += UnityEngine.StackTraceUtility.ExtractStackTrace () + "\n";
				UnityEngine.Debug.LogException(e);
//				throw new Exception("fail");
			}
		}

		private static BasicTest instance = null;
		void Awake(){
			if(instance == null){ 	//making sure we only initialize one instance.
				instance = this;
				GameObject.DontDestroyOnLoad(this.gameObject);
			} else {					//Destroying unused instances.
				GameObject.Destroy(this);
			}

			sTestLog = "";
			_eventQueue = new Queue<Dictionary<string, object>> ();

//			JSONObject jsonObject = new JSONObject (@"{
//  ""scores"" : [
//
//  ],
//  ""className"" : ""Level"",
//""challenges"" : [
//
//  ],
//  ""worldId"" : ""lvl1"",
//  ""worlds"" : [
//
//  ]
//}");
//			Level.fromJSONObject (jsonObject);
		}

//		bool SoomlaInit(string secret) {
//	#if !UNITY_EDITOR
//	#if UNITY_IOS
//			[DllImport ("__Internal")]
//			private static extern void soomla_SetLogDebug(bool debug);
//			[DllImport ("__Internal")]
//			private static extern void soomla_Init(string secret);
//					
//			/// <summary>
//			/// Initializes the SOOMLA SDK.
//			/// </summary>
//			public static bool Initialize() {
//				soomla_SetLogDebug(true);
//				soomla_Init(secret);
//				return true;
//			}
//	#endif
//	#if UNITY_ANDROID
//			AndroidJNI.PushLocalFrame(100);
//			using(AndroidJavaClass jniSoomlaClass = new AndroidJavaClass("com.soomla.Soomla")) {
//				jniSoomlaClass.CallStatic("initialize", secret);
//			}
//			//init EventHandler
//			using(AndroidJavaClass jniEventHandler = new AndroidJavaClass("com.soomla.unity.SoomlaEventHandler")) {
//				jniEventHandler.CallStatic("initialize");
//			}
//			AndroidJNI.PopLocalFrame(IntPtr.Zero);
//			return true;
//
//	#endif
//	#else
//			return false;
//	#endif
//		}

		// Use this for initialization
		void Start () {

			_textStyle.wordWrap = true;
			_textStyle.richText = true;	
			_textStyle.normal.textColor = Color.white;
			_textStyle.fontSize = 32;

			// clear last DB storage so test run anew
			string dbName = "store.kv.db";
			string dbPath = null;
#if UNITY_ANDROID
			// file approach seems to not work
//			dbPath = Application.persistentDataPath + "/" + dbName;
			// even replacing the path doesn't
//			dbPath = Regex.Replace(dbPath, "/.+/data/com", "/data/data/com");

			// try via Context (works)
			UnityEngine.Debug.LogWarning("TESTING-> try to delete db via Context.deleteDatabase..");
			AndroidJavaClass jc = new AndroidJavaClass("com.unity3d.player.UnityPlayer"); 
			AndroidJavaObject jo = jc.GetStatic<AndroidJavaObject>("currentActivity");
			bool deleted = jo.Call<bool>("deleteDatabase", new object[] {dbName});
			UnityEngine.Debug.LogWarning ("TESTING-> deleted?=" + deleted);
			
#elif UNITY_IOS
			dbPath = "/private" + Application.persistentDataPath + "/../Library/Application Support/" + dbName;
#endif
			if (dbPath != null) {
				UnityEngine.Debug.LogWarning ("TESTING-> db file at:" + dbPath);
				bool exists = System.IO.File.Exists(dbPath);
				UnityEngine.Debug.LogWarning ("TESTING-> db file exists?=" + exists);
				if(exists) {
					UnityEngine.Debug.LogWarning ("TESTING-> DELETE db file at:" + dbPath);
#if UNITY_ANDROID
					// file approach seems to not work
					System.IO.File.Delete (dbPath);
#elif UNITY_IOS
					System.IO.File.Delete (dbPath);
#endif
				}
			}


	//		SoomlaInit ("hansolo");
			StoreEvents.OnSoomlaStoreInitialized += onSoomlaStoreInitialized;
			// TBD: these are are initialized internally
			// TBD: is that ok, or from outside?
//			CoreEvents.Initialize ();
//			LevelUpEvents.Initialize ();
			MuffinRushAssets assets = new MuffinRushAssets ();
			SoomlaUtils.LogDebug(TAG, "IStoreAssets:" + assets.ToString ());
			SoomlaStore.Initialize (assets);
		}

		public void onSoomlaStoreInitialized() {
//			Coroutine<bool> testScoreAscCR = Coroutine<bool>(testScoreAsc());
//			yield return testScoreAscCR.coroutine;
//			try {
//				if (testScoreAscCR.Value) {
//				}
//
//			}
//			catch (Exception e) {
//				//and handle any exceptions here
//			}

			LevelUpEvents.OnGateOpened += onGateOpen;
			LevelUpEvents.OnLevelEnded += onLevelEnded;
			LevelUpEvents.OnLevelStarted += onLevelStarted;
			LevelUpEvents.OnMissionCompleted += onMissionCompleted;
			LevelUpEvents.OnMissionCompletionRevoked += onMissionCompletedRevoked;
			LevelUpEvents.OnScoreRecordChanged += onScoreRecordChanged;
			LevelUpEvents.OnWorldCompleted += onWorldCompleted;
			StoreEvents.OnGoodBalanceChanged += onGoodBalanceChanged;
			CoreEvents.OnRewardGiven += onRewardGiven;
			CoreEvents.OnRewardTaken += onRewardTaken;

			StartCoroutine(runTests());
//			runTests ();
		}

		private IEnumerator/*void*/ runTests() {
//			testScoreAsc();
//			if (!Assert.Equals (0, _eventQueue.Count)) {
//				dumpQueue("testScoreAsc");
//			}
//			yield return StartCoroutine(testScoreDsc ());
//			if (!Assert.Equals (0, _eventQueue.Count)) {
//				dumpQueue("testScoreDsc");
//			}
//			yield return StartCoroutine(testRangeScoreOverflow ());
//			if (!Assert.Equals (0, _eventQueue.Count)) {
//				dumpQueue("testRangeScoreOverflow");
//			}
//			yield return StartCoroutine(testRecordMission ());
//			if (!Assert.Equals (0, _eventQueue.Count)) {
//				dumpQueue("testRecordMission");
//			}
			yield return StartCoroutine(testChallenge ());
			yield return new WaitForSeconds (2);
			if (!Assert.Equals (0, _eventQueue.Count)) {
				dumpQueue("testChallenge");
			}
//			yield return StartCoroutine(testLevel());
//			if (!Assert.Equals (0, _eventQueue.Count)) {
//				dumpQueue("testLevel");
//			}

			yield return null;
		}

		private void dumpQueue(string testName) {
			string queueLog = "";
			while (_eventQueue.Count > 0) {
				Dictionary<string, object> expectedEvent = _eventQueue.Dequeue();
				foreach( KeyValuePair<string, object> kvp in expectedEvent )
				{
					queueLog += string.Format("Key = {0}, Value = {1}", 
					                          kvp.Key, kvp.Value) + "\n";
				}
				string msg = testName + ">>> unconsumed event:" + queueLog;
				sTestLog += msg;
				UnityEngine.Debug.LogError(msg);
			}
		}

		void Update() {
			if (Application.platform == RuntimePlatform.Android) {
				if (Input.GetKeyUp(KeyCode.Escape)) {
					//quit application on back button
					Application.Quit();
					return;
				}
			}

			if(Input.touchCount > 0)
			{
				touch = Input.touches[0];
				if (touch.phase == TouchPhase.Moved)
				{
					scrollPosition.x += touch.deltaPosition.x;
					scrollPosition.y += touch.deltaPosition.y;
				}
				if (touch.phase == TouchPhase.Ended)
				{
					// impart momentum, using last delta as the starting velocity
					// ignore delta < 10; rounding issue can cause ultra-high velocity
					if (Mathf.Abs(touch.deltaPosition.y) >= 10) {
						scrollVelocity = (int)(touch.deltaPosition.y / touch.deltaTime);
					}
					timeTouchPhaseEnded = Time.time;

				}
			}
			if (Input.touchCount != 1)
			{
				if ( scrollVelocity != 0.0f )
				{
					// slow down over time
					float t = (Time.time - timeTouchPhaseEnded) / inertiaDuration;
					float frameVelocity = Mathf.Lerp(scrollVelocity, 0, t);
					scrollPosition.y += frameVelocity * Time.deltaTime;
					
					// after N seconds, we've stopped
					if (t >= inertiaDuration) scrollVelocity = 0.0f;
				}
				return;
			}
		}

		void OnGUI() {

			GUILayout.BeginArea (new Rect(10, 10, Screen.width-10, Screen.height-10));
			scrollPosition = GUILayout.BeginScrollView (scrollPosition, GUILayout.Width (Screen.width-10), GUILayout.Height (Screen.height-10));
			/*changes made in the below 2 lines */
			GUI.skin.box.wordWrap = true;     // set the wordwrap on for box only.
			GUILayout.Box(sTestLog, _textStyle);        // just your message as parameter.			
			GUILayout.EndScrollView ();			
			GUILayout.EndArea();

//			Rect rcView = new Rect (10, 10, Screen.width - 10, Screen.height - 10);
//			scrollPosition = GUI.BeginScrollView(scrollPosition, new Vector2(0, Mathf.Infinity), rcView);
//			GUI.TextArea (rcView, sTestLog, _textStyle);
//			GUI.EndScrollView ();
		}

		private void createFruitsGoblins() {
			World mainWorld = new World("main_world");

			World machineA = new World("machine_a", 20, true);
			World machineB = new World("machine_b", 20, true);
			World machineC = new World("machine_c", 20, true);
			World machineD = new World("machine_d", 20, true);

			BadgeReward bronzeMedal = new BadgeReward("badge_bronzeMedal", "Bronze Medal");
			BadgeReward silverMedal = new BadgeReward("badge_silverMedal", "Silver Medal");
			BadgeReward goldMedal = new BadgeReward("badge_goldMedal", "Gold Medal");
			VirtualItemReward perfectMedal = new VirtualItemReward("item_perfectMedal", "Perfect Medal", "perfect_medal", 1);


			/** Testing **/

			Level lvl1 = (Level)machineA.InnerWorldsList[0];
			lvl1.AssignReward(goldMedal);
		}
			
		private IEnumerator testLevel() {
			sTestLog += "testLevel...";		

			List<World> worlds = new List<World>();
			Level lvl1 = new Level("lvl1", false);
			worlds.Add(lvl1);
			
			//LevelUp.Initialize(worlds);
			
			// no gates
			Assert.assertTrue(lvl1.CanStart());
			Assert.assertTrue(lvl1.State == Level.LevelState.Idle);

			// setup expected event queue
			_eventQueue.Clear ();
			Dictionary<string, object> evtLvlStarted = new Dictionary<string, object> {
				{ "handler", "onLevelStarted" },
				{ "id", "lvl1" }
			};
			Dictionary<string, object> evtLvlEnded = new Dictionary<string, object> {
				{ "handler", "onLevelEnded" },
				{ "id", "lvl1" }
			};
			Dictionary<string, object> evtWorldCompleted = new Dictionary<string, object> {
				{ "handler", "onWorldCompleted" },
				{ "id", "lvl1" }
			};

			_eventQueue.Enqueue (evtLvlStarted); // level started
			_eventQueue.Enqueue (evtLvlEnded); // level ended
			_eventQueue.Enqueue (evtWorldCompleted); // world completed
			
			lvl1.Start();
			Assert.assertTrue(lvl1.State == Level.LevelState.Running);
			
			yield return new WaitForSeconds(1);
			// check level time measure
			double playDuration = lvl1.GetPlayDuration();
			SoomlaUtils.LogDebug(TAG, "playDuration = " + playDuration);
			sTestLog += "playDuration = " + playDuration + "\n";
			Assert.assertTrue(playDuration >= 1);
			Assert.assertFalse(playDuration > 2);
			
			lvl1.Pause();
			yield return new WaitForSeconds(1);
			// make sure no changes after pause
			playDuration = lvl1.GetPlayDuration();
			SoomlaUtils.LogDebug(TAG, "playDuration = " + playDuration);
			sTestLog += "playDuration = " + playDuration + "\n";;
			Assert.assertTrue(playDuration >= 1);
			Assert.assertFalse(playDuration > 2);
			Assert.assertTrue(lvl1.State == Level.LevelState.Paused);
			
			lvl1.Resume();
			yield return new WaitForSeconds(1);
			// make sure working after resume
			playDuration = lvl1.GetPlayDuration();
			SoomlaUtils.LogDebug(TAG, "playDuration = " + playDuration);
			sTestLog += "playDuration = " + playDuration + "\n";;
			Assert.assertTrue(playDuration >= 2);
			Assert.assertFalse(playDuration > 3);
			Assert.assertTrue(lvl1.State == Level.LevelState.Running);
			
			lvl1.End(false);
			Assert.assertTrue(lvl1.State == Level.LevelState.Ended);
			Assert.assertFalse(lvl1.IsCompleted());
			
			lvl1.SetCompleted(true);
			Assert.assertTrue(lvl1.IsCompleted());

			// it seems there is a delay of ~0.5-1.0 seconds of saving to storage
			Assert.assertEquals(playDuration, lvl1.GetSlowestDuration(), 0.9);
			Assert.assertEquals(playDuration, lvl1.GetFastestDuration(), 0.9);
			Assert.assertEquals(1, lvl1.GetTimesPlayed());
			Assert.assertEquals(1, lvl1.GetTimesStarted());		

			UnityEngine.Debug.LogError("Done! SOOMLA");

			if (!sAssertionError) {
				sTestLog += "<color=green>SUCCESS</color>\n";
			}
			sAssertionError = false;

			yield return null;
		}

		public IEnumerator testScoreAsc() {
			sTestLog += "testScoreAsc...";
			UnityEngine.Debug.LogError("testScoreAsc SOOMLA");
			bool higherIsBetter = true;
			string scoreId = "score_asc";
			Score scoreAsc = new Score(scoreId, "ScoreAsc", higherIsBetter);		

			_eventQueue.Clear ();

			Assert.assertEquals(0, scoreAsc.GetTempScore(), 0.01);
			scoreAsc.StartValue = 0;
			scoreAsc.Inc(1);
			Assert.assertEquals(1, scoreAsc.GetTempScore(), 0.01);
			scoreAsc.Dec(1);
			Assert.assertEquals(0, scoreAsc.GetTempScore(), 0.01);
			scoreAsc.Inc(10);
			Assert.assertEquals(10, scoreAsc.GetTempScore(), 0.01);
	//		//mExpectedRecordValue = 10;
			SoomlaUtils.LogError (TAG, "Enqueue 10.0");
				_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 10.0 }
			});
			scoreAsc.SaveAndReset();
			Assert.assertEquals(10, scoreAsc.Latest, 0.01);
			Assert.assertEquals(0, scoreAsc.GetTempScore(), 0.01);
			scoreAsc.SetTempScore(20);
	//		//mExpectedRecordValue = 0;
//				_eventQueue.Enqueue (new Dictionary<string, object> {
//				{ "handler", "onScoreRecordChanged" },
//				{ "id", scoreId }, 
//				{ "val", 0.0 }
//			});
			scoreAsc.Reset();
			Assert.assertEquals(0, scoreAsc.Latest, 0.01);
			Assert.assertEquals(0, scoreAsc.GetTempScore(), 0.01);
			scoreAsc.SetTempScore(30);
			Assert.assertTrue(scoreAsc.HasTempReached(30));
			Assert.assertFalse(scoreAsc.HasTempReached(31));
	//		//mExpectedRecordValue = 30;
			SoomlaUtils.LogError (TAG, "Enqueue 30.0");
				_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 30.0 }
			});
			scoreAsc.SaveAndReset();
			Assert.assertEquals(30, scoreAsc.Latest, 0.01);
			Assert.assertEquals(30, scoreAsc.Record, 0.01);
			scoreAsc.SetTempScore(15);
	//		//mExpectedRecordValue = 30;
				SoomlaUtils.LogError (TAG, "Enqueue 30.0");
				_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 30.0 }
			});		
			scoreAsc.SaveAndReset();
			Assert.assertEquals(15, scoreAsc.Latest, 0.01);
			Assert.assertEquals(30, scoreAsc.Record, 0.01);
			Assert.assertTrue(scoreAsc.HasRecordReached(30));
			Assert.assertFalse(scoreAsc.HasRecordReached(31));

			UnityEngine.Debug.LogError("Done! SOOMLA");

			if (!sAssertionError) {
				sTestLog += "<color=green>SUCCESS</color>\n";
			}
			sAssertionError = false;					

			yield return null;
		}
	
		public IEnumerator testScoreDsc() {
			sTestLog += "testScoreDsc...";
			UnityEngine.Debug.LogError("testScoreDsc SOOMLA");
			double desiredRecord = 20;
			string scoreId = "score_dsc";
			Score scoreDsc = new Score(scoreId, "ScoreDsc", false);
			scoreDsc.StartValue = 100;

			_eventQueue.Clear ();

			//mExpectedScoreEventId = scoreId;
			//mExpectedRecordValue = 100;
			_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 100.0 }
			});
			
			string missionId = "score_dsc_record_mission_id";
			RecordMission recordMission = new RecordMission(missionId, "ScoreDscRecordMission", scoreId, desiredRecord);

			scoreDsc.Reset();
			Assert.assertEquals(100, scoreDsc.GetTempScore(), 0.01);
			
			scoreDsc.Dec(50);
			Assert.assertEquals(50, scoreDsc.GetTempScore(), 0.01);
			//mExpectedRecordValue = 50;
			_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 50.0 }
			});
			scoreDsc.SaveAndReset(); // start value is 100
			Assert.assertEquals(50, scoreDsc.Latest, 0.01);
			Assert.assertEquals(100, scoreDsc.GetTempScore(), 0.01);
			scoreDsc.SetTempScore(20);
			//mExpectedRecordValue = 20;
			_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 20.0 }
			});
			//mExpectedMissionEventId = missionId;
			_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onMissionCompleted" },
				{ "id", missionId }, 
				{ "val", 100.0 }
			});
			scoreDsc.SaveAndReset();
			Assert.assertEquals(20, scoreDsc.Latest, 0.01);
			Assert.assertEquals(20, scoreDsc.Record, 0.01);
			scoreDsc.SetTempScore(30);
			//mExpectedRecordValue = 20;
			_eventQueue.Enqueue (new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", 20.0 }
			});
			scoreDsc.SaveAndReset();
			Assert.assertEquals(30, scoreDsc.Latest, 0.01);
			Assert.assertEquals(20, scoreDsc.Record, 0.01);
			Assert.assertTrue(scoreDsc.HasRecordReached(20));
			Assert.assertFalse(scoreDsc.HasRecordReached(19));

			UnityEngine.Debug.LogError("Done! SOOMLA");
			
			if (!sAssertionError) {
				sTestLog += "<color=green>SUCCESS</color>\n";
			}
			sAssertionError = false;

			yield return null;
		}
		
		
		public IEnumerator testRangeScoreOverflow() {
			sTestLog += "testRangeScoreOverflow...";
			UnityEngine.Debug.LogError("testRangeScoreOverflow SOOMLA");
			string scoreIdUp = "testRangeScoreOverflow_score_up_id";
			RangeScore rangeScoreUp = new RangeScore(scoreIdUp, "RangeScore", true, new RangeScore.SRange(0, 100));
			string scoreIdDown = "testRangeScoreOverflow_score_down_id";
			RangeScore rangeScoreDown = new RangeScore(scoreIdDown, "RangeScore", false, new RangeScore.SRange(0, 100));

			_eventQueue.Clear ();

			//mExpectedScoreEventId = scoreIdUp;
			//mExpectedRecordValue = 0;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreIdUp }, 
				{ "val", 0.0 }
			});
		
			rangeScoreUp.Inc(101);
			Assert.assertEquals(100, rangeScoreUp.GetTempScore(), 0.01);
			rangeScoreUp.Reset();
			rangeScoreUp.Inc(5);
			rangeScoreUp.Dec(10);
			Assert.assertEquals(0, rangeScoreUp.GetTempScore(), 0.01);
			
			//mExpectedScoreEventId = scoreIdDown;
			//mExpectedRecordValue = 100;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreIdDown }, 
				{ "val", 100.0 }
			});
			
			rangeScoreDown.Dec(101);
			Assert.assertEquals(0, rangeScoreDown.GetTempScore(), 0.01);
			rangeScoreDown.Reset();
			rangeScoreDown.Dec(5);
			rangeScoreDown.Inc(10);
			Assert.assertEquals(100, rangeScoreDown.GetTempScore(), 0.01);

			UnityEngine.Debug.LogError("Done! SOOMLA");
			
			if (!sAssertionError) {
				sTestLog += "<color=green>SUCCESS</color>\n";
			}
			sAssertionError = false;	

			yield return null;
		}
		
		
		public IEnumerator testRecordMission() {
			sTestLog += "testRecordMission...";
			UnityEngine.Debug.LogError("testRecordMission SOOMLA");

			string missionId = "record_mission";
			string scoreId = "record_mission_score";
			string rewardId = "record_mission_reward_badge_id";
			double desiredScore = 55.0;
			BadgeReward badgeReward = new BadgeReward(rewardId, "RecordMissionBadge");
			List<Reward> rewards = new List<Reward>();
			rewards.Add(badgeReward);
			Score score = new Score(scoreId, "RecordMissionScore", true);
			RecordMission recordMission = new RecordMission(
				missionId, "RecordMission", rewards, scoreId, desiredScore);

			_eventQueue.Clear ();
			//mExpectedScoreEventId = scoreId;
			//mExpectedRecordValue = desiredScore;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onScoreRecordChanged" },
				{ "id", scoreId }, 
				{ "val", desiredScore }
			});
			//mExpectedMissionEventId = missionId;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onMissionCompleted" },
				{ "id", missionId }, 
			});
			//mExpectedRewardEventId = rewardId;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onRewardGiven" },
				{ "id", rewardId }, 
			});

			Assert.assertFalse(recordMission.IsCompleted());
			Assert.assertFalse(badgeReward.Owned);
			
			score.SetTempScore(desiredScore);
			score.SaveAndReset();
			
			Assert.assertTrue(recordMission.IsCompleted());
			Assert.assertTrue(badgeReward.Owned);
			
			// test revoke
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onMissionCompletedRevoked" },
				{ "id", missionId }, 
			});
			//mExpectedRewardEventId = rewardId;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onRewardTaken" },
				{ "id", rewardId }, 
			});

			recordMission.SetCompleted(false);

			UnityEngine.Debug.LogError("Done! SOOMLA");
			
			if (!sAssertionError) {
				sTestLog += "<color=green>SUCCESS</color>\n";
			}
			sAssertionError = false;	

			yield return null;
		}
		
		
//		public void testBalanceMission() {
//			string missionId = "balance_mission_id";
//			string balanceMissionItemId = "balance_mission_item_id";
//			string rewardId = "balance_mission_reward_id";
//			string rewardItemId = "balance_mission_reward_item_id";
//			
//			VirtualItemReward virtualItemReward = new VirtualItemReward(rewardId, "ItemReward", rewardItemId, 1);
//			List<Reward> rewards = new List<Reward>();
//			rewards.Add(virtualItemReward);
//			BalanceMission balanceMission = new BalanceMission(
//				missionId, "BalanceMission",
//				rewards, balanceMissionItemId, 5);
//			
//			// assert basics
//			Assert.assertFalse(balanceMission.IsCompleted());
//			Assert.assertFalse(virtualItemReward.Owned);
//			try {
//				Assert.assertEquals(0, StoreInventory.GetItemBalance(ITEM_ID_BALANCE_MISSION));
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//			
//			// give less and assert false completed/rewarded
//			// set event expectations
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(ITEM_ID_BALANCE_MISSION, 3, 3));
//			try {
//				StoreInventory.GiveItem(balanceMissionItemId, 3);
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//			
//			// set event expectations
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(ITEM_ID_BALANCE_MISSION, 2, 5));
//			// this will happen directly after
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(ITEM_ID_BALANCE_MISSION_REWARD, 1, 1));
//			
//			//mExpectedMissionEventId = missionId;
//			//mExpectedRewardEventId = rewardId;
//			
//			try {
//				StoreInventory.GiveItem(balanceMissionItemId, 2);
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//			
//			Assert.assertTrue(balanceMission.IsCompleted());
//			Assert.assertTrue(virtualItemReward.Owned);
//		}
		
		
		public IEnumerator testChallenge() {
			sTestLog += "testChallenge...";
			UnityEngine.Debug.LogError("testChallenge SOOMLA");

			string missionId1 = "challenge_mission1";
			Mission mission1 = new ActionMission(missionId1, "ChallengeMission1");
			string missionId2 = "challenge_mission2";
			Mission mission2 = new ActionMission(missionId2, "ChallengeMission1");
			List<Mission> missions = new List<Mission>();
			missions.Add(mission1);
			missions.Add(mission2);
			List<Reward> rewards = new List<Reward>();
			string rewardId = "challenge_badge_reward_id";
			BadgeReward badgeReward = new BadgeReward(rewardId, "ChallengeBadgeRewardId");
			rewards.Add(badgeReward);
			string challengeId = "challenge_id";
			Challenge challenge = new Challenge(challengeId, "Challenge", missions, rewards);

			_eventQueue.Clear ();

			Assert.assertFalse(challenge.IsCompleted());
			
			//mExpectedMissionEventId = missionId1;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onMissionCompleted" },
				{ "id", missionId1 }, 
			});

			mission1.SetCompleted(true);
			
			//mExpectedMissionEventId = missionId2;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onMissionCompleted" },
				{ "id", missionId2 }, 
			});
			//mExpectedChallengeId = challengeId;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onMissionCompleted" },
				{ "id", challengeId }, 
			});
			//mExpectedRewardEventId = rewardId;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onRewardGiven" },
				{ "id", rewardId }, 
			});
			
			Assert.assertFalse(challenge.IsCompleted());
			Assert.assertFalse(badgeReward.Owned);
			
			mission2.SetCompleted(true);
			
			Assert.assertTrue(challenge.IsCompleted());
			
			// test revoke
			//mExpectedMissionEventId = missionId1;
			_eventQueue.Enqueue(new Dictionary<string, object> {
				{ "handler", "onMissionCompletedRevoked" },
				{ "id", missionId1 }, 
			});
			mission1.SetCompleted(false);
			Assert.assertFalse(challenge.IsCompleted());
			Assert.assertFalse(badgeReward.Owned);	

			UnityEngine.Debug.LogError("Done! SOOMLA");
			
			if (!sAssertionError) {
				sTestLog += "<color=green>SUCCESS</color>\n";
			}
			sAssertionError = false;

			yield return null;
		}
		
		
//		public void testRewards() {
//			bool given;
//			//        BadgeReward badgeReward = new BadgeReward();
//			//        badgeReward.setRepeatable(false);
//			//        Assert.assertFalse(badgeReward.Owned);
//			//        given = badgeReward.give();
//			//        Assert.assertTrue(given);
//			//        given = badgeReward.give();
//			//        Assert.assertFalse(given);
//			//        Assert.assertTrue(badgeReward.Owned);
//			//
//			//        RandomReward randomReward = new RandomReward();
//			//        SequenceReward sequenceReward = new SequenceReward();
//			
//			string rewardId = "vi_reward";
//			VirtualItemReward virtualItemReward = new VirtualItemReward(rewardId, "VIReward", 3, ITEM_ID_VI_REWARD);
//			virtualItemReward.Repeatable = true;
//			
//			try {
//				Assert.assertEquals(0, StoreInventory.GetItemBalance(ITEM_ID_VI_REWARD));
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//			
//			// expected events (async)
//			//mExpectedRewardEventId = rewardId;
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(ITEM_ID_VI_REWARD, 3, 3));
//			
//			given = virtualItemReward.Give();
//			Assert.assertTrue(given);
//			
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(ITEM_ID_VI_REWARD, 3, 6));
//			
//			given = virtualItemReward.Give();
//			Assert.assertTrue(given);
//			
//			try {
//				Assert.assertEquals(6, StoreInventory.GetItemBalance(ITEM_ID_VI_REWARD));
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//		}
		
		
//		public void testRecordGateWithRangeScore() {
//			List<World> worlds = new List<World>();
//			string lvl1Id = "lvl1_recordgate_rangescore";
//			Level lvl1 = new Level(lvl1Id, false);
//			string lvl2Id = "lvl2_recordgate_rangescore";
//			Level lvl2 = new Level(lvl2Id, true);
//			string scoreId = "range_score";
//			RangeScore rangeScore = new RangeScore(scoreId, "RangeScore", new RangeScore.SRange(0, 100));
//			string recordGateId = "record_gate";
//			RecordGate recordGate = new RecordGate(recordGateId, scoreId, 100);
//			lvl1.addScore(rangeScore);
//			lvl2.addGate(recordGate);
//			
//			worlds.Add(lvl1);
//			worlds.Add(lvl2);
//			
//			LevelUp.GetInstance().Initialize(worlds, null);
//			
//			// open level
//			Assert.assertTrue(lvl1.CanStart());
//			// protected by gate
//			Assert.assertFalse(lvl2.CanStart());
//			
//			//mExpectedWorldEventId = lvl1Id;
//			
//			lvl1.Start();
//			
//			int i = 0;
//			Assert.assertFalse(recordGate.IsOpen());
//			Assert.assertFalse(recordGate.CanOpen());
//			while (i < 100) {
//				rangeScore.Inc(1);
//				++i;
//			}
//			Assert.assertFalse(recordGate.IsOpen());
//			Assert.assertFalse(recordGate.CanOpen());
//			
//			//mExpectedGateEventId = recordGateId;
//			//mExpectedScoreEventId = scoreId;
//			//mExpectedRecordValue = 100;
//			
//			rangeScore.Inc(1);
//			
//			lvl1.End(true);
//			
//			Assert.assertFalse(recordGate.IsOpen());
//			Assert.assertTrue(recordGate.CanOpen());
//			
//			bool opened = recordGate.TryOpen();
//			Assert.assertTrue(opened);
//			Assert.assertTrue(recordGate.IsOpen());
//			Assert.assertTrue(recordGate.CanOpen());
//			
//			Assert.assertTrue(lvl2.CanStart());
//			
//			//mExpectedWorldEventId = lvl2Id;
//			
//			lvl2.Start();
//			lvl2.End(true);
//			
//			Assert.assertTrue(lvl2.IsCompleted());
//			
//			// test json serialization
//			//        string json = KeyValueStorage.getValue(LevelUp.DB_KEY_PREFIX + "model");
//			//        writeFile("tests/levelup.json", json);
//		}
//		
//		
//		public void testBalanceGate() {
//			List<World> worlds = new List<World>();
//			string lvl1Id = "lvl1_balancegate";
//			Level lvl1 = new Level(lvl1Id);
//			string lvl2Id = "lvl2_balancegate";
//			Level lvl2 = new Level(lvl2Id);
//			string itemId = ITEM_ID_BALANCE_GATE;
//			string balanceGateId = "balance_gate";
//			
//			BalanceGate balanceGate = new BalanceGate(balanceGateId, itemId, 1);
//			lvl2.addGate(balanceGate);
//			
//			worlds.Add(lvl1);
//			worlds.Add(lvl2);
//			
//			LevelUp.GetInstance().Initialize(worlds, null);
//			
//			// open level
//			Assert.assertTrue(lvl1.CanStart());
//			// protected by gate
//			Assert.assertFalse(lvl2.CanStart());
//			
//			// set up events expectations (async)
//			//mExpectedWorldEventId = lvl1Id;
//			//mExpectedGateEventId = balanceGateId;
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(itemId, 1, 1));
//			
//			lvl1.Start();
//			
//			Assert.assertFalse(balanceGate.IsOpen());
//			Assert.assertFalse(balanceGate.CanOpen());
//			
//			try {
//				StoreInventory.GiveItem(itemId, 1);
//				Assert.assertTrue(balanceGate.CanOpen());
//				
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e);
//			}
//			
//			lvl1.End(true);
//			
//			Assert.assertFalse(balanceGate.IsOpen());
//			Assert.assertTrue(balanceGate.CanOpen());
//			
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(itemId, -1, 0));
//			
//			bool opened = balanceGate.TryOpen();
//			Assert.assertTrue(opened);
//			Assert.assertTrue(balanceGate.IsOpen());
//			Assert.assertTrue(balanceGate.CanOpen());
//			
//			Assert.assertTrue(lvl2.CanStart());
//			
//			//mExpectedWorldEventId = lvl2Id;
//			
//			lvl2.Start();
//			lvl2.End(true);
//			
//			Assert.assertTrue(lvl2.IsCompleted());
//		}
//		
//		
//		public void testWorldCompletionGate() {
//			List<World> worlds = new List<World>();
//			string lvl1Id = "lvl1_completiongate";
//			Level lvl1 = new Level(lvl1Id);
//			string lvl2Id = "lvl2_completiongate";
//			Level lvl2 = new Level(lvl2Id);
//			string worldGateId = "world_gate";
//			
//			WorldCompletionGate lvl1CompletionGate =
//				new WorldCompletionGate(worldGateId, lvl1Id);
//			lvl2.addGate(lvl1CompletionGate);
//			
//			worlds.Add(lvl1);
//			worlds.Add(lvl2);
//			
//			LevelUp.GetInstance().Initialize(worlds);
//			
//			// open level
//			Assert.assertTrue(lvl1.CanStart());
//			// protected by gate
//			Assert.assertFalse(lvl2.CanStart());
//			
//			//mExpectedWorldEventId = lvl1Id;
//			
//			lvl1.Start();
//			
//			Assert.assertFalse(lvl1CompletionGate.IsOpen());
//			Assert.assertFalse(lvl1CompletionGate.CanOpen());
//			
//			// set up events expectations (async)
//			//mExpectedGateEventId = worldGateId;
//			
//			lvl1.End(true);
//			
//			Assert.assertFalse(lvl1CompletionGate.IsOpen());
//			Assert.assertTrue(lvl1CompletionGate.CanOpen());
//			
//			bool opened = lvl1CompletionGate.TryOpen();
//			Assert.assertTrue(opened);
//			Assert.assertTrue(lvl1CompletionGate.IsOpen());
//			Assert.assertTrue(lvl1CompletionGate.CanOpen());
//			
//			Assert.assertTrue(lvl2.CanStart());
//			
//			//mExpectedWorldEventId = lvl2Id;
//			
//			lvl2.Start();
//			lvl2.End(true);
//			
//			Assert.assertTrue(lvl2.IsCompleted());
//		}

//		public void testPurchasableGate(bool vi) {
//			List<World> worlds = new List<World>();
//			string lvl1Id = "lvl1_purchasablegate";
//			Level lvl1 = new Level(lvl1Id);
//			Level lvl2 = new Level("lvl2_purchasablegate");
//			string itemId = vi ? ITEM_ID_PURCHASE_GATE_VI : ITEM_ID_PURCHASE_GATE_MARKET;
//			string purchaseGateId = vi ? "purchase_gate_vi": "purchase_gate_market";
//			
//			PurchasableGate purchasableGate = new PurchasableGate(purchaseGateId, itemId);
//			lvl2.addGate(purchasableGate);
//			
//			worlds.Add(lvl1);
//			worlds.Add(lvl2);
//			
//			LevelUp.GetInstance().Initialize(worlds);
//			
//			// open level
//			Assert.assertTrue(lvl1.CanStart());
//			// protected by gate
//			Assert.assertFalse(lvl2.CanStart());
//			lvl1.Start();
//			
//			Assert.assertFalse(purchasableGate.IsOpen());
//			Assert.assertFalse(purchasableGate.CanOpen());
//			
//			lvl1.End(true);
//			
//			Assert.assertFalse(purchasableGate.IsOpen());
//			Assert.assertTrue(purchasableGate.CanOpen());
//			
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(itemId, 10, 10));
//			
//			try {
//				StoreInventory.GiveItem(itemId, 10);
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//			
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(itemId, -10, 0));
//			
//			try {
//				StoreInventory.BuyItem(itemId);
//			} catch (InsufficientFundsException e) {
//				Assert.fail(e.ToString());
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//			
//			bool opened = purchasableGate.TryOpen();
//			Assert.assertTrue(opened);
//			Assert.assertTrue(purchasableGate.IsOpen());
//			Assert.assertTrue(purchasableGate.CanOpen());
//			
//			Assert.assertTrue(lvl2.CanStart());
//			lvl2.Start();
//			lvl2.End(true);
//			
//			Assert.assertTrue(lvl2.IsCompleted());
//		}
		
		 /* should pass iff GatesList.mAutoOpenBehavior == false */
//		public void testGatesList() {
//			string recordGateId1 = "gates_list_record_gate_id1";
//			string scoreId1 = "gates_list_score_id1";
//			double desiredRecord1 = 100;
//			string recordGateId2 = "gates_list_record_gate_id2";
//			string scoreId2 = "gates_list_score_id2";
//			double desiredRecord2 = 200;
//			
//			Score score1 = new Score(scoreId1, "GatesListScore1", true);
//			Score score2 = new Score(scoreId2, "GatesListScore2", true);
//			
//			List<World> worlds = new List<World>();
//			string lvl1Id = "lvl1_gates_list";
//			Level lvl1 = new Level(lvl1Id);
//			lvl1.addScore(score1);
//			lvl1.addScore(score2);
//			worlds.Add(lvl1);
//			
//			RecordGate recordGate1 = new RecordGate(recordGateId1, scoreId1, desiredRecord1);
//			RecordGate recordGate2 = new RecordGate(recordGateId2, scoreId2, desiredRecord2);
//			
//			List<Gate> gates = new List<Gate>();
//			gates.Add(recordGate1);
//			gates.Add(recordGate2);
//			
//			string gateListORId = "gate_list_OR_id";
//			GatesListOR gatesListOR = new GatesListOR(gateListORId, gates);
//			
//			string gateListANDId = "gate_list_AND_id";
//			GatesListAND gatesListAND = new GatesListAND(gateListANDId, gates);
//			
//			LevelUp.GetInstance().Initialize(worlds);
//			
//			//mExpectedGateEventId = recordGateId1;
//			//mExpectedScoreEventId = scoreId1;
//			//mExpectedRecordValue = desiredRecord1;
//			
//			score1.SetTempScore(desiredRecord1);
//			score1.SaveAndReset();
//			
//			Assert.assertTrue(recordGate1.CanOpen());
//			Assert.assertFalse(recordGate1.IsOpen());
//			
//			//mExpectedGatesListEventId = gateListORId;
//			
//			Assert.assertTrue(recordGate1.TryOpen());
//			
//			Assert.assertTrue(gatesListOR.CanOpen());
//			Assert.assertFalse(gatesListOR.IsOpen());
//			
//			Assert.assertFalse(gatesListAND.CanOpen());
//			Assert.assertFalse(gatesListAND.IsOpen());
//			
//			Assert.assertTrue(gatesListOR.TryOpen());
//			
//			//mExpectedGateEventId = recordGateId2;
//			//mExpectedScoreEventId = scoreId2;
//			//mExpectedRecordValue = desiredRecord2;
//			
//			score2.SetTempScore(desiredRecord2);
//			score2.SaveAndReset();
//			
//			Assert.assertTrue(recordGate2.CanOpen());
//			Assert.assertFalse(recordGate2.IsOpen());
//			
//			//mExpectedGatesListEventId = gateListANDId;
//			
//			Assert.assertTrue(recordGate2.TryOpen());
//			
//			Assert.assertTrue(gatesListOR.CanOpen());
//			Assert.assertTrue(gatesListOR.IsOpen());
//			
//			Assert.assertTrue(gatesListAND.CanOpen());
//			Assert.assertFalse(gatesListAND.IsOpen());
//			
//			Assert.assertTrue(gatesListAND.TryOpen());
//			Assert.assertTrue(gatesListAND.IsOpen());
//		}
		
		 /* should pass iff GatesList.mAutoOpenBehavior == true */
//		public void testGatesListAutoOpenBehavior() {
//			//        GatesList.mChildrenCanOpenIsEnough = true;
//			//        GatesList.mAutoOpenBehavior = true;
//			
//			string recordGateId1 = "gates_list_AO_record_gate_id1";
//			string scoreId1 = "gates_list_AO_score_id1";
//			double desiredRecord1 = 10;
//			string recordGateId2 = "gates_list_AO_record_gate_id2";
//			string scoreId2 = "gates_list_AO_score_id2";
//			double desiredRecord2 = 20;
//			
//			Score score1 = new Score(scoreId1, "GatesAOListScore1", true);
//			Score score2 = new Score(scoreId2, "GatesAOListScore2", true);
//			
//			List<World> worlds = new List<World>();
//			string lvl1Id = "lvl1_gates_list_AO";
//			Level lvl1 = new Level(lvl1Id);
//			lvl1.addScore(score1);
//			lvl1.addScore(score2);
//			worlds.Add(lvl1);
//			
//			RecordGate recordGate1 = new RecordGate(recordGateId1, scoreId1, desiredRecord1);
//			RecordGate recordGate2 = new RecordGate(recordGateId2, scoreId2, desiredRecord2);
//			
//			List<Gate> gates = new List<Gate>();
//			gates.Add(recordGate1);
//			gates.Add(recordGate2);
//			
//			string gateListORId = "gate_list_AO_OR_id";
//			GatesListOR gatesListOR = new GatesListOR(gateListORId, gates);
//			
//			string gateListANDId = "gate_list_AO_AND_id";
//			GatesListAND gatesListAND = new GatesListAND(gateListANDId, gates);
//			
//			LevelUp.GetInstance().Initialize(worlds, null);
//			
//			//mExpectedGatesListEventId = gateListORId;
//			//mExpectedGateEventId = recordGateId1;
//			//mExpectedScoreEventId = scoreId1;
//			//mExpectedRecordValue = desiredRecord1;
//			
//			score1.SetTempScore(desiredRecord1);
//			score1.SaveAndReset();
//			
//			Assert.assertTrue(recordGate1.CanOpen());
//			Assert.assertFalse(recordGate1.IsOpen());
//			
//			Assert.assertTrue(recordGate1.TryOpen());
//			
//			Assert.assertTrue(gatesListOR.CanOpen());
//			// todo: could be confusing, no need to TryOpen it
//			Assert.assertTrue(gatesListOR.IsOpen());
//			
//			Assert.assertFalse(gatesListAND.CanOpen());
//			Assert.assertFalse(gatesListAND.IsOpen());
//			
//			// todo: could be confusing, no need to TryOpen it
//			Assert.assertTrue(gatesListOR.TryOpen());
//			
//			//mExpectedGatesListEventId = gateListANDId;
//			//mExpectedGateEventId = recordGateId2;
//			//mExpectedScoreEventId = scoreId2;
//			//mExpectedRecordValue = desiredRecord2;
//			
//			score2.SetTempScore(desiredRecord2);
//			score2.SaveAndReset();
//			
//			Assert.assertTrue(recordGate2.CanOpen());
//			Assert.assertFalse(recordGate2.IsOpen());
//			
//			Assert.assertTrue(recordGate2.TryOpen());
//			
//			Assert.assertTrue(gatesListOR.CanOpen());
//			Assert.assertTrue(gatesListOR.IsOpen());
//			
//			Assert.assertTrue(gatesListAND.CanOpen());
//			// todo: could be confusing, no need to TryOpen it
//			Assert.assertTrue(gatesListAND.IsOpen());
//			
//			// todo: could be confusing, no need to TryOpen it
//			Assert.assertTrue(gatesListOR.TryOpen());
//			Assert.assertTrue(gatesListAND.IsOpen());
//		}
		
		
//		public void testVirtualItemScore() {
//			List<World> worlds = new List<World>();
//			string lvl1Id = "lvl1_viscore";
//			Level lvl1 = new Level(lvl1Id);
//			string itemId = ITEM_ID_VI_SCORE;
//			string scoreId = "vi_score";
//			VirtualItemScore virtualItemScore = new VirtualItemScore(
//				scoreId, "VI_Score", itemId);
//			lvl1.addScore(virtualItemScore);
//			
//			worlds.Add(lvl1);
//			
//			LevelUp.GetInstance().Initialize(worlds);
//			
//			try {
//				Assert.assertEquals(0, StoreInventory.GetItemBalance(itemId));
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//			
//			// set up events expectations (async)
//			//mExpectedWorldEventId = lvl1Id;
//			mVirtualItemExpectationQueue.Add(new VirtualItemBalanceEventExpectation(itemId, 2, 2));
//			//mExpectedScoreEventId = scoreId;
//			//mExpectedRecordValue = 2;
//			
//			lvl1.Start();
//			virtualItemScore.Inc(2);
//			lvl1.End(true);
//			
//			try {
//				Assert.assertEquals(2, StoreInventory.GetItemBalance(itemId));
//			} catch (VirtualItemNotFoundException e) {
//				Assert.fail(e.ToString());
//			}
//		}
		
		
//		public void testCounts() {
//			
//			
//			List<World> worlds = new List<World>();
//			Level level1 = new Level("level1");
//			Level level2 = new Level("level2");
//			Level level2_1 = new Level("level2_1");
//			level2.addInnerWorld(level2_1);
//			
//			World world1 = new World("world1");
//			world1.addInnerWorld(level1);
//			world1.addInnerWorld(level2);
//			
//			World world2 = new World("world2");
//			
//			World world3 = new World("world3");
//			World world3_1 = new World("world3_1");
//			World world3_2 = new World("world3_2");
//			
//			Level level3_1_1 = new Level("level3_1_1");
//			Level level3_1_2 = new Level("level3_1_2");
//			Level level3_1_1_1 = new Level("level3_1_1_1");
//			level3_1_1.addInnerWorld(level3_1_1_1);
//			world3_1.addInnerWorld(level3_1_1);
//			world3_1.addInnerWorld(level3_1_2);
//			
//			world3.addInnerWorld(world3_1);
//			world3.addInnerWorld(world3_2);
//			
//			worlds.Add(world1);
//			worlds.Add(world2);
//			worlds.Add(world3);
//			
//			
//			LevelUp.GetInstance().Initialize(worlds);
//			Assert.assertEquals(LevelUp.GetInstance().GetLevelCount(), 6);
//			Assert.assertEquals(LevelUp.GetInstance().GetWorldCount(false), 5);
//			Assert.assertEquals(LevelUp.GetInstance().GetWorldCount(true), 6 + 5);
//			Assert.assertEquals(LevelUp.GetInstance().GetLevelCountInWorld(world1), 3);
//			Assert.assertEquals(LevelUp.GetInstance().GetLevelCountInWorld(world2), 0);
//			Assert.assertEquals(LevelUp.GetInstance().GetLevelCountInWorld(world3), 3);
//			
//			// Test before world completion
//			Assert.assertEquals(LevelUp.GetInstance().GetCompletedLevelCount(), 0);
//			Assert.assertEquals(LevelUp.GetInstance().GetCompletedWorldCount(), 0);
//			
//			// Test after world completion
//			// TODO: Decouple event expectations from test
//			//mExpectedWorldEventId = level1.getWorldId();
//			level1.SetCompleted(true);
//			//mExpectedWorldEventId = level3_1_1_1.getWorldId();
//			level3_1_1_1.SetCompleted(true);
//			//mExpectedWorldEventId = world1.getWorldId();
//			world1.SetCompleted(true);
//			//mExpectedWorldEventId = world3_1.getWorldId();
//			world3_1.SetCompleted(true);
//			Assert.assertEquals(LevelUp.GetInstance().GetCompletedLevelCount(), 2);
//			Assert.assertEquals(LevelUp.GetInstance().GetCompletedWorldCount(), 2);
//		}
		
		// EVENTS

		private void onGateOpen(Gate gate) {
			string gateId = gate.GateId;
			bool isGatesList = gate is GatesList;
			bool isAdHocGate = UUID_REGEX.IsMatch (gateId);
			string msg = "<color=yellow>onEvent/onGateOpen:</color>" + gateId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogError (TAG, "_eventQueue.Count="+_eventQueue.Count);

//			string expectedGateEventId = isGatesList ?
//				(isAdHocGate ? gateId : mExpectedGatesListEventId) :
//					expected["id"];

			Assert.assertEquals(expected["id"], gateId);
			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
		}
		
		private void onLevelEnded(Level level) {
			string worldId = level.WorldId;
			string msg = "<color=yellow>onEvent/onLevelEnded:</color>" + worldId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogError (TAG, "_eventQueue.Count="+_eventQueue.Count);
			Assert.assertEquals(expected["id"], worldId);
		}
		
		private void onLevelStarted(Level level) {
			string worldId = level.WorldId;
			string msg = "<color=yellow>onEvent/onLevelStarted:</color>" + worldId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogError (TAG, "_eventQueue.Count="+_eventQueue.Count);
			Assert.assertEquals(expected["id"], worldId);
			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
		}
		
		private void onMissionCompleted(Mission mission) {
			string missionId = mission.MissionId;
			bool isChallenge = mission is Challenge;
			string msg = "<color=yellow>onEvent/onMissionCompleted:</color>" + missionId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogError (TAG, "_eventQueue.Count="+_eventQueue.Count);
			Assert.assertEquals(expected["id"], missionId);
			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
		}
		
		private void onMissionCompletedRevoked(Mission mission) {
			string missionId = mission.MissionId;
			bool isChallenge = mission is Challenge;
			string msg = "<color=yellow>onEvent/onMissionCompletedRevoked:</color>" + missionId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogError (TAG, "_eventQueue.Count="+_eventQueue.Count);
			Assert.assertEquals(expected["id"], missionId);
			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
		}
		
		private void onScoreRecordChanged(Score score) {
			string scoreId = score.ScoreId;
			double record = score.Record;
			string msg = "<color=yellow>onEvent/onScoreRecordChanged:</color>" + score + "->" + record;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogError (TAG, "_eventQueue.Count="+_eventQueue.Count);
			Assert.assertEquals(expected["id"], scoreId);
			Assert.assertEquals(expected["val"] as double? ?? 0.9999, record, 0.1);
			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
		}
		
		private void onWorldCompleted(World world) {
			string worldId = world.WorldId;
			string msg = "<color=yellow>onEvent/onWorldCompleted:</color>" + worldId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogError (TAG, "_eventQueue.Count="+_eventQueue.Count);
			Assert.assertEquals(expected["id"], worldId);
			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
		}

		private void onGoodBalanceChanged(VirtualGood vg, int balance, int amountAdded) {
//			final String itemId = goodBalanceChangedEvent.getGood().getItemId();
//			System.out.println("onEvent/GoodBalanceChangedEvent:" + itemId);
//			
//			Assert.assertFalse(mVirtualItemExpectationQueue.isEmpty());
//			VirtualItemBalanceEventExpectation expectation = mVirtualItemExpectationQueue.remove();
//			
//			Assert.assertEquals(expectation.ExpectedVirtualItemId, itemId);
//			Assert.assertEquals(expectation.ExpectedVirtualItemAmountAdded, goodBalanceChangedEvent.getAmountAdded());
//			Assert.assertEquals(expectation.ExpectedVirtualItemBalance, goodBalanceChangedEvent.getBalance());

//			string worldId = world.WorldId;
//			string msg = "<color=yellow>onEvent/onWorldCompleted:</color>" + worldId;
//			sTestLog += msg + "\n";
//			SoomlaUtils.LogDebug(TAG, msg);
//			Dictionary<string, object> expected = _eventQueue.Dequeue ();
//			Assert.assertEquals(expected["id"], worldId);
//			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
		}

		private void onRewardGiven(Reward reward) {
			string rewardId = reward.RewardId;
			string msg = "<color=yellow>onEvent/onRewardGiven:</color>" + rewardId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogError (TAG, "_eventQueue.Count="+_eventQueue.Count);
			Assert.assertEquals(expected["id"], rewardId);
			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
		}

		private void onRewardTaken(Reward reward) {
			string rewardId = reward.RewardId;
			string msg = "<color=yellow>onEvent/onRewardTaken:</color>" + rewardId;
			sTestLog += msg + "\n";
			SoomlaUtils.LogDebug(TAG, msg);
			Dictionary<string, object> expected = _eventQueue.Dequeue ();
			SoomlaUtils.LogError (TAG, "_eventQueue.Count="+_eventQueue.Count);
			Assert.assertEquals(expected["id"], rewardId);
			Assert.assertEquals(expected["handler"], System.Reflection.MethodBase.GetCurrentMethod().Name);
		}

		public class Coroutine<T>{
			public T Value {
				get{
					if(e != null){
						throw e;
					}
					return returnVal;
				}
			}
			private T returnVal;
			private Exception e;
			public Coroutine coroutine;
			
			public IEnumerator InternalRoutine(IEnumerator coroutine){
				while(true){
					try{
						if(!coroutine.MoveNext()){
							yield break;
						}
					}
					catch(Exception e){
						this.e = e;
						yield break;
					}
					object yielded = coroutine.Current;
					if(yielded != null && yielded.GetType() == typeof(T)){
						returnVal = (T)yielded;
						yield break;
					}
					else{
						yield return coroutine.Current;
					}
				}
			}
		}
	}
}
